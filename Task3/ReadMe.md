    **Алгоритмы сортировки**

**Сортировка выбором**

Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве

Выбранный язык C++

Исходный массив: 64, 25, 12, 22, 11
Отсортированный массив: 11, 12, 22, 25, 64

Объяснение работы алгоритма:
•	На каждом шаге в неотсортированной части массива ищется минимальный элемент
•	Найденный минимальный элемент меняется местами с первым элементом неотсортированной части
•	После каждого прохода отсортированная часть увеличивается на один элемент
•	Процесс повторяется для оставшейся неотсортированной части массива

Временная сложность алгоритма: O(n²) в худшем, среднем и лучшем случаях, где n - количество элементов в массиве.


**Сортировка обменом (пузырьком) (Bubble Sort)**

Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько
раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном
порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.

Выбранный язык Python

Исходный массив:64 34 25 12 22 11 90 
Отсортированный массив:11 12 22 25 34 64 90 

Объяснение работы алгоритма:
•	На каждом проходе сравниваются соседние элементы массива
•	Если элементы находятся в неправильном порядке, они меняются местами
•	После каждого прохода наибольший элемент "всплывает" в конец массива
•	Процесс повторяется для оставшейся неотсортированной части

Временная сложность алгоритма: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (уже отсортированный массив), где n - количество элементов в массиве.

**Сортировка вставками (Insertion Sort)**

Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

Выбранный язык C++

Исходный массив: 12 11 13 5 6 
Отсортированный массив: 5 6 11 12 13

Объяснение работы алгоритма:
- Массив делится на отсортированную и неотсортированную части
- На каждом шаге берется очередной элемент из неотсортированной части
- Элемент вставляется в правильную позицию в отсортированной части
- Элементы большие чем вставляемый сдвигаются вправо

Временная сложность алгоритма: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (уже отсортированный массив), где n - количество элементов в массиве.


**Сортировка слиянием (Merge Sort)**

Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам,
сортировке половин и их слиянии.

Выбранный язык C++

Исходный массив: 38 27 43 3 9 82 10 
Отсортированный массив: 3 9 10 27 38 43 82

Объяснение работы алгоритма:
- Массив рекурсивно делится пополам до базового случая
- Отсортированные подмассивы сливаются в один отсортированный массив
- При слиянии элементы сравниваются и добавляются в результирующий массив в порядке возрастания

Временная сложность алгоритма: O(n log n) во всех случаях (худшем, среднем и лучшем), где n - количество элементов в массиве.

**Сортировка Шелла (Shellsort)**

Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует
между собой элементы, стоящие на местах, кратных определённому шагу. 

Выбранный язык Python

Исходный массив: 12 34 54 2 3 
Отсортированный массив: 2 3 12 34 54

Объяснение работы алгоритма:
•	Используется последовательность промежутков (gaps) для сравнения и обмена элементов
•	На каждом проходе сравниваются элементы, отстоящие друг от друга на определенном расстоянии
•	После каждого прохода промежуток уменьшается
•	На последнем проходе промежуток равен 1 (аналогично сортировке вставками)

Временная сложность алгоритма: O(n²) в худшем случае, O(n log²n) в среднем и лучшем случаях, где n - количество элементов в массиве.


**Быстрая сортировка (Quick Sort)**

Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.

Выбранный язык C++

Исходный массив: 10 7 8 9 1 5 
Отсортированный массив: 1 5 7 8 9 10


Объяснение работы алгоритма:
•	Выбирается опорный элемент (pivot)
•	Массив разбивается так, что элементы меньше опорного перемещаются слева, а больше - справа
•	Опорный элемент занимает свою окончательную позицию
•	Процесс рекурсивно повторяется для левой и правой частей

Временная сложность алгоритма: O(n log n) в среднем случае, O(n²) в худшем случае (уже отсортированный массив), где n - количество элементов в массиве.

**Пирамидальная сортировка**
Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

Выбранный язык C++

Исходный массив: 12 11 13 5 6 7 
Отсортированный массив: 5 6 7 11 12 13 


Объяснение работы алгоритма:
•	Сначала строится max-heap (куча), где наибольший элемент находится в корне
•	Корень кучи (наибольший элемент) перемещается в конец массива
•	Размер кучи уменьшается, и куча перестраивается
•	Процесс повторяется пока все элементы не будут отсортированы
Временная сложность алгоритма: O(n log n) во всех случаях (худшем, среднем и лучшем), где n - количество элементов в массиве.
 
     **Алгоритмы поиск**
     
**Последовательный (линейный) поиск **

Последовательный (линейный) поиск — простейший вид поиска заданного элемента на
некотором множестве. Осуществляется путём последовательного сравнения очередного
рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод
является наименее эффективным, так как его временная сложность составляет O(n), где n —
количество элементов в списке. Однако он прост в реализации и может быть полезен для
небольших списков или в тех случаях, когда данные не отсортированы.

Выбранный язык Python

Вывод - Элемент найден на позиции: 3

Объяснение работы алгоритма:
•	Последовательно проверяются все элементы массива от начала до конца
•	При нахождении элемента возвращается его индекс
•	Если элемент не найден, возвращается -1

Временная сложность алгоритма: O(n) в худшем случае, O(1) в лучшем случае (элемент первый), где n - количество элементов в массиве.

**Бинарный (двоичный, дихотомический) поиск**

Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на
упорядоченном множестве, осуществляемый путём неоднократного деления этого множества
на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск
заканчивается при совпадении искомого элемента с элементом, который является границей
между частями множества или при отсутствии искомого элемента. Преимуществом бинарного
поиска является более низкая трудоёмкость по сравнению с последовательным поиском.
Недостаток заключается в том, что он применим только на отсортированных множествах

Выбранный язык Python

Вывод - Элемент найден на позиции: 3

Объяснение работы алгоритма:
•	Поиск выполняется в отсортированном массиве
•	На каждом шаге область поиска уменьшается вдвое
•	Сравнивается средний элемент с искомым значением
•	В зависимости от результата поиск продолжается в левой или правой половине
Временная сложность алгоритма: O(log n) в худшем и среднем случаях, O(1) в лучшем случае (элемент в середине), где n - количество элементов в массиве.

**Интерполирующий поиск**

Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных,
таких как массивы или списки. Он предсказывает позицию нужного элемента на основе
разницы значений. Эффективен, если элементы распределены достаточно равномерно.

Выбранный язык C++

Элемент найден на позиции: 4

Объяснение работы алгоритма:
•	Улучшенная версия бинарного поиска для равномерно распределенных данных
•	Позиция вычисляется по интерполяционной формуле вместо простого деления пополам
•	Рекурсивно сужает область поиска на основе значения искомого элемента

Временная сложность алгоритма: O(log log n) в среднем случае для равномерного распределения, O(n) в худшем случае (неравномерное распределение), где n - количество элементов в массиве.

**Поиск по Фибоначчи**
Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения
целевого значения в отсортированной коллекции, такой как массив или список. По принципу
он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций
для сравнения

Выбраный язык Python

Элемент найден на позиции: 8


Объяснение работы алгоритма:
•	Использует числа Фибоначчи для определения позиций сравнения
•	Делит массив на части с пропорциями, соответствующими числам Фибоначчи
•	Эффективен для больших массивов и при доступе к данным с большими задержками

Временная сложность алгоритма: O(log n) в среднем и худшем случаях, где n - количество элементов в массиве.








